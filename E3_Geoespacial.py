# -*- coding: utf-8 -*-
"""T3_geoespa.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12V9NyVPWuG8umTIqYnmnNrZcFgpcGvVU
"""

# === 1. Instalar dependencias necesarias ===
!pip install geopandas pyproj shapely --quiet

# === 2. Subir archivo geojson ===
from google.colab import files
uploaded = files.upload()

# === 3. Cargar archivo geojson como GeoDataFrame ===
import geopandas as gpd
import io

# Obtener nombre del archivo cargado
filename = next(iter(uploaded))
gdf = gpd.read_file(filename)

# === 4. Verificar y asignar CRS si no est√° definido ===
if gdf.crs is None:
    print("No CRS definido, asignando EPSG:4326 (WGS84 lat/lon)")
    gdf.set_crs(epsg=4326, inplace=True)
elif gdf.crs.to_epsg() != 4326:
    print(f"CRS original es {gdf.crs}, reproyectando a EPSG:4326 primero")
    gdf = gdf.to_crs(epsg=4326)

# === 5. Reproyectar a Origen Nacional de Colombia (EPSG:3116) ===
gdf_3116 = gdf.to_crs(epsg=3116)

# === 6. Extraer coordenadas planas ===
gdf_3116["x"] = gdf_3116.geometry.x
gdf_3116["y"] = gdf_3116.geometry.y

# === 7. Convertir a DataFrame completo (sin geometr√≠a si se desea) ===
df_final = gdf_3116.drop(columns=["geometry"])

# === 8. Mostrar resultado final ===
import pandas as pd
pd.set_option('display.max_columns', None)
df_final

df_final.to_csv("coordenadas_planas.csv", index=False)
files.download("coordenadas_planas.csv")

# === 1. Instalar dependencias necesarias ===
!pip install geopandas shapely --quiet

# === 2. Subir archivo geojson ===
from google.colab import files
uploaded = files.upload()

# === 3. Cargar geojson como GeoDataFrame ===
import geopandas as gpd
import pandas as pd

filename = next(iter(uploaded))
gdf = gpd.read_file(filename)

# === 4. Verificar que el CRS sea proyectado (planas en metros) ===
if gdf.crs is None:
    print("No tiene CRS. Se recomienda EPSG:3116 (MAGNA Origen Nacional). Asignando por defecto.")
    gdf.set_crs(epsg=3116, inplace=True)
elif not gdf.crs.is_projected:
    raise ValueError("El sistema de coordenadas debe estar en metros (no geogr√°ficas). Usa EPSG:3116 o similar.")

# === 5. Calcular la matriz de distancias ===
from scipy.spatial import distance_matrix

# Extraer coordenadas planas
coords = gdf.geometry.apply(lambda geom: (geom.x, geom.y)).tolist()
dist_matrix = distance_matrix(coords, coords)

# === 6. Definir umbral de vecindad (en metros) ===
umbral = 10000  # puedes cambiar este valor (por ejemplo: 100, 250, 1000)

# Crear matriz binaria de vecindad
vecindad = (dist_matrix <= umbral).astype(int)

# Eliminar auto-vecindad (diagonal en 0)
import numpy as np
np.fill_diagonal(vecindad, 0)

# === 7. Convertir a DataFrame para visualizar mejor ===
matriz_df = pd.DataFrame(vecindad, index=gdf.index, columns=gdf.index)
matriz_df

import matplotlib.pyplot as plt
from shapely.geometry import LineString
from matplotlib.collections import LineCollection

# === 1. Crear l√≠neas entre vecinos ===
lineas = []
for i in range(len(coords)):
    for j in range(i + 1, len(coords)):  # solo parte superior (evita duplicados)
        if vecindad[i][j] == 1:
            linea = LineString([coords[i], coords[j]])
            lineas.append(linea)

# === 2. Crear figura ===
fig, ax = plt.subplots(figsize=(8, 8))

# Dibujar l√≠neas
for linea in lineas:
    x, y = linea.xy
    ax.plot(x, y, color='gray', linewidth=0.8, alpha=0.6)

# Dibujar puntos
xs, ys = zip(*coords)
ax.scatter(xs, ys, color='blue', s=30, zorder=5)

# Etiquetas opcionales
for idx, (x, y) in enumerate(coords):
    ax.text(x, y, str(idx), fontsize=8, ha='right', va='bottom')

ax.set_title("Matriz de Vecindad por Distancia")
ax.set_aspect('equal')
plt.grid(True)
plt.show()

# === 1. Instalar dependencias necesarias ===
!pip install geopandas shapely --quiet

# === 2. Subir archivo geojson ===
from google.colab import files
uploaded = files.upload()

# === 3. Leer el GeoJSON ===
import geopandas as gpd
import pandas as pd

filename = next(iter(uploaded))
gdf = gpd.read_file(filename)

# === 4. Asegurar CRS en coordenadas planas ===
if gdf.crs is None:
    print("No tiene CRS. Se recomienda EPSG:3116 (MAGNA Origen Nacional). Asignando por defecto.")
    gdf.set_crs(epsg=3116, inplace=True)
elif not gdf.crs.is_projected:
    raise ValueError("El sistema de coordenadas debe estar en metros (no geogr√°ficas). Usa EPSG:3116 o similar.")

# === 5. Filtrar solo los puntos con desborde = True ===
if "DESBORDE" not in gdf.columns:
    raise ValueError("La columna 'desborde' no existe en el GeoJSON.")

gdf_DESBORDE = gdf[gdf["DESBORDE"] == True].copy()
print(f"Se encontraron {len(gdf_DESBORDE)} puntos con DESBORDE = True.")

# === 6. Calcular matriz de distancias entre puntos filtrados ===
from scipy.spatial import distance_matrix

coords = gdf_DESBORDE.geometry.apply(lambda geom: (geom.x, geom.y)).tolist()
dist_matrix = distance_matrix(coords, coords)

# === 7. Definir umbral de vecindad (en metros) ===
umbral = 3000  # cambia seg√∫n tu criterio
import numpy as np
vecindad = (dist_matrix <= umbral).astype(int)
np.fill_diagonal(vecindad, 0)

# === 8. Visualizar la matriz como DataFrame ===
matriz_df = pd.DataFrame(vecindad, index=gdf_DESBORDE.index, columns=gdf_DESBORDE.index)
matriz_df

import matplotlib.pyplot as plt
from shapely.geometry import LineString

lineas = []
for i in range(len(coords)):
    for j in range(i + 1, len(coords)):
        if vecindad[i][j] == 1:
            lineas.append(LineString([coords[i], coords[j]]))

# Dibujar
fig, ax = plt.subplots(figsize=(8, 8))

# L√≠neas
for linea in lineas:
    x, y = linea.xy
    ax.plot(x, y, color='gray', linewidth=0.8, alpha=0.6)

# Puntos
xs, ys = zip(*coords)
ax.scatter(xs, ys, color='blue', s=30, zorder=5)

# Etiquetas (√≠ndice original del GeoDataFrame)
for idx, (x, y) in zip(gdf_DESBORDE.index, coords):
    ax.text(x, y, str(idx), fontsize=8, ha='right', va='bottom')

ax.set_title("Vecindad de puntos con DESBORDE = True")
ax.set_aspect('equal')
plt.grid(True)
plt.show()

# === 1. Instalar dependencias necesarias ===
!pip install geopandas shapely contextily --quiet

# === 2. Subir el archivo geojson ===
from google.colab import files
uploaded = files.upload()

# === 3. Cargar y preparar el GeoDataFrame ===
import geopandas as gpd
filename = next(iter(uploaded))
gdf = gpd.read_file(filename)

# Asegurar que tiene coordenadas proyectadas
if gdf.crs is None:
    gdf.set_crs(epsg=3116, inplace=True)

# Verificar que la columna DESBORDE exista
if "DESBORDE" not in gdf.columns:
    raise ValueError("La columna 'DESBORDE' no existe en el GeoJSON.")

# Filtrar puntos con DESBORDE = True
gdf_desborde = gdf[gdf["DESBORDE"] == True].copy()

# Reproyectar a EPSG:3857 (Web Mercator)
gdf_3857 = gdf_desborde.to_crs(epsg=3857)

# Extraer coordenadas
coords = gdf_3857.geometry.apply(lambda geom: (geom.x, geom.y)).tolist()

# Calcular matriz de vecindad
from scipy.spatial import distance_matrix
import numpy as np
dist_matrix = distance_matrix(coords, coords)
umbral = 000  # en metros
vecindad = (dist_matrix <= umbral).astype(int)
np.fill_diagonal(vecindad, 0)

# === 4. Graficar con mapa de fondo ===
import matplotlib.pyplot as plt
import contextily as ctx
from shapely.geometry import LineString

# Crear l√≠neas entre vecinos
lineas = []
for i in range(len(coords)):
    for j in range(i + 1, len(coords)):
        if vecindad[i][j] == 1:
            lineas.append(LineString([coords[i], coords[j]]))

# Crear GeoDataFrame de l√≠neas
import geopandas as gpd
gdf_lineas = gpd.GeoDataFrame(geometry=lineas, crs=3857)

# Graficar
fig, ax = plt.subplots(figsize=(10, 10))
gdf_lineas.plot(ax=ax, color='gray', linewidth=1, alpha=0.5)
gdf_3857.plot(ax=ax, color='blue', markersize=40)

# A√±adir etiquetas opcionales
for idx, (x, y) in zip(gdf_3857.index, coords):
    ax.text(x, y, str(idx), fontsize=8, ha='right', va='bottom')

# A√±adir mapa de fondo (tiles sobrios)
ctx.add_basemap(ax, source=ctx.providers.CartoDB.Positron)

ax.set_title("Red de Vecindad (DESBORDE=True) con fondo de mapa")
ax.set_axis_off()
plt.show()

# === 1. Instalar dependencias necesarias ===
!pip install geopandas libpysal contextily matplotlib --quiet

# === 2. Subir archivo geojson ===
from google.colab import files
uploaded = files.upload()

# === 3. Leer el archivo y preparar GeoDataFrame ===
import geopandas as gpd

filename = next(iter(uploaded))
gdf = gpd.read_file(filename)

# Asegurar CRS correcto (EPSG:3116 = Origen Nacional)
if gdf.crs is None:
    gdf.set_crs(epsg=3116, inplace=True)
elif gdf.crs.to_epsg() != 3116:
    gdf = gdf.to_crs(epsg=3116)

# === 4. Filtrar puntos con DESBORDE == True ===
if "DESBORDE" not in gdf.columns:
    raise ValueError("La columna 'DESBORDE' no existe.")
gdf_desborde = gdf[gdf["DESBORDE"] == True].copy()

if gdf_desborde.empty:
    raise ValueError("No hay puntos con DESBORDE == True.")

# === 5. Calcular matriz de pesos espaciales por inverso de la distancia ===
from libpysal.weights import DistanceBand

umbral = 5000  # metros
w_dist = DistanceBand.from_dataframe(gdf_desborde, threshold=umbral, binary=False)

# === 6. Convertir matriz de pesos a DataFrame ===
import pandas as pd
from collections import defaultdict

# Crear diccionario de pesos inversos
weights_dict = defaultdict(dict)
for i in w_dist.neighbors:
    for j, w in zip(w_dist.neighbors[i], w_dist.weights[i]):
        weights_dict[i][j] = w

# Convertir a matriz de DataFrame (llenar con 0 si no hay conexi√≥n)
index_list = gdf_desborde.index.tolist()
peso_df = pd.DataFrame(0.0, index=index_list, columns=index_list)

for i in weights_dict:
    for j in weights_dict[i]:
        peso_df.loc[i, j] = weights_dict[i][j]

# === 7. Mostrar la matriz de pesos ===
import numpy as np
pd.set_option("display.precision", 5)
peso_df.replace(0, np.nan, inplace=True)  # para distinguir los no vecinos
peso_df

# === 8. Visualizaci√≥n del punto focal y sus vecinos ===
import matplotlib.pyplot as plt
import contextily as ctx
from shapely.geometry import LineString

# Elegir un punto focal (primero del DataFrame)
focal_id = gdf_desborde.index[0]
vecinos_ids = list(w_dist[focal_id].keys())

# Crear l√≠neas desde foco a sus vecinos
lines = []
focus_geom = gdf_desborde.loc[focal_id].geometry
for vid in vecinos_ids:
    neighbor_geom = gdf_desborde.loc[vid].geometry
    lines.append(LineString([focus_geom, neighbor_geom]))

gdf_lineas = gpd.GeoDataFrame(geometry=lines, crs=3116)

# Reproyectar todo a EPSG:3857 para contexto visual
gdf_3857 = gdf_desborde.to_crs(epsg=3857)
gdf_lineas_3857 = gdf_lineas.to_crs(epsg=3857)
focus_3857 = gdf_3857.loc[[focal_id]]
vecinos_3857 = gdf_3857.loc[vecinos_ids]
buffer_3857 = focus_3857.geometry.centroid.buffer(umbral)

# Graficar
fig, ax = plt.subplots(figsize=(10, 10))
gdf_3857.plot(ax=ax, color='lightgray', markersize=30, label="Todos los puntos")
gdf_lineas_3857.plot(ax=ax, color='gray', linewidth=1)
vecinos_3857.plot(ax=ax, color='lime', markersize=50, label="Vecinos")
focus_3857.plot(ax=ax, color='red', markersize=80, label="Punto focal")
buffer_3857.plot(ax=ax, edgecolor='red', facecolor='none', linewidth=2, linestyle='--')

# Etiquetas opcionales
for idx, row in gdf_3857.iterrows():
    x, y = row.geometry.x, row.geometry.y
    ax.text(x, y, str(idx), fontsize=8, ha='right')

ctx.add_basemap(ax, source=ctx.providers.CartoDB.Positron)
ax.set_title(f"Vecindad espacial (inverso de distancia) desde el punto {focal_id}")
ax.set_axis_off()
plt.legend()
plt.show()

# === 1. Ver columnas disponibles para usar como variable de an√°lisis ===
print("Variables disponibles para calcular rezago espacial:\n")
print(gdf_desborde.columns.drop('geometry'))

# === 2. Pedir al usuario que elija una variable ===
var_objetivo = input("\nüëâ Escribe el nombre EXACTO de la variable para calcular el rezago espacial: ")

# === 3. Verificar que la variable existe ===
if var_objetivo not in gdf_desborde.columns:
    raise ValueError(f"La variable '{var_objetivo}' no existe en el GeoDataFrame.")

# === 4. Calcular rezago espacial usando matriz de pesos ===
from libpysal.weights import lag_spatial

gdf_desborde[f'w_{var_objetivo}'] = lag_spatial(w_dist, gdf_desborde[var_objetivo])

# === 5. Comparar original vs. rezago espacial ===
gdf_desborde[[var_objetivo, f'w_{var_objetivo}']].head()

# === 6. Estandarizar la variable original y su rezago espacial ===
gdf_desborde[f'{var_objetivo}_std'] = (gdf_desborde[var_objetivo] - gdf_desborde[var_objetivo].mean()) / gdf_desborde[var_objetivo].std()
gdf_desborde[f'w_{var_objetivo}_std'] = lag_spatial(w_dist, gdf_desborde[f'{var_objetivo}_std'])

# Mostrar algunas observaciones para inspecci√≥n
gdf_desborde[[f'{var_objetivo}_std', f'w_{var_objetivo}_std']].head()

# === 1. Asegurarse de tener contextily
!pip install contextily mapclassify --quiet

# === 2. Graficar variable y rezago con mapa de fondo ===
import matplotlib.pyplot as plt
import contextily as ctx

# Reproyectar a EPSG:3857 para que encaje con el mapa base
gdf_3857 = gdf_desborde.to_crs(epsg=3857)

fig, axs = plt.subplots(1, 2, figsize=(14, 7))
ax1, ax2 = axs

# Variable original
gdf_3857.plot(
    column=var_objetivo,
    cmap='viridis',
    scheme='quantiles',
    k=6,
    edgecolor='white',
    linewidth=0,
    alpha=0.9,
    legend=True,
    ax=ax1
)
ctx.add_basemap(ax1, source=ctx.providers.CartoDB.Positron)
ax1.set_title(f"{var_objetivo}")
ax1.set_axis_off()

# Rezago espacial
gdf_3857.plot(
    column=f'w_{var_objetivo}',
    cmap='viridis',
    scheme='quantiles',
    k=6,
    edgecolor='white',
    linewidth=0,
    alpha=0.9,
    legend=True,
    ax=ax2
)
ctx.add_basemap(ax2, source=ctx.providers.CartoDB.Positron)
ax2.set_title(f"Rezago espacial de {var_objetivo}")
ax2.set_axis_off()

plt.tight_layout()
plt.show()

# === 1. Instalar dependencias ===
!pip install seaborn --quiet

# === 2. Librer√≠as necesarias ===
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
from libpysal.weights import lag_spatial

# === 3. Mostrar variables disponibles ===
variables_numericas = gdf_desborde.select_dtypes(include=[np.number]).columns.tolist()
print("Variables num√©ricas disponibles:", variables_numericas)

# === 4. Preguntar por la variable objetivo ===
var_moran = input("üëâ Escribe el nombre EXACTO de la variable num√©rica para el gr√°fico de Moran: ")

if var_moran not in variables_numericas:
    raise ValueError(f"La variable '{var_moran}' no existe o no es num√©rica.")

# === 5. Crear variables estandarizadas ===
gdf_desborde[f'{var_moran}_std'] = (gdf_desborde[var_moran] - gdf_desborde[var_moran].mean()) / gdf_desborde[var_moran].std()

# Calcular rezago espacial sobre la variable estandarizada
gdf_desborde[f'w_{var_moran}_std'] = lag_spatial(w_dist, gdf_desborde[f'{var_moran}_std'])

# Estandarizar tambi√©n el rezago espacial
gdf_desborde[f'w_{var_moran}_std_z'] = (gdf_desborde[f'w_{var_moran}_std'] - gdf_desborde[f'w_{var_moran}_std'].mean()) / gdf_desborde[f'w_{var_moran}_std'].std()

# === 6. Gr√°fico de Moran con seaborn ===
f, ax = plt.subplots(1, figsize=(7, 7))

sns.regplot(
    x=gdf_desborde[f'{var_moran}_std'],
    y=gdf_desborde[f'w_{var_moran}_std_z'],
    ci=None,
    line_kws={'color': 'red'},
    scatter_kws={'alpha': 0.6, 'edgecolor': 'k'}
)

# L√≠neas gu√≠a
ax.axvline(0, color='gray', linestyle='--', alpha=0.5)
ax.axhline(0, color='gray', linestyle='--', alpha=0.5)

# T√≠tulo y ejes
ax.set_title(f"Gr√°fico de Moran ‚Äì {var_moran}", fontsize=14)
ax.set_xlabel(f"{var_moran} estandarizada (Z)")
ax.set_ylabel(f"Rezago espacial estandarizado (WZ)")

plt.grid(True)
plt.tight_layout()
plt.show()

# === 1. Instalar dependencias necesarias ===
!pip install esda mapclassify contextily --quiet

# === 2. Librer√≠as necesarias
from esda.moran import Moran_Local
import numpy as np
import matplotlib.pyplot as plt
import contextily as ctx

# === 3. Seleccionar variable (misma que en el gr√°fico de Moran)
variables_numericas = gdf_desborde.select_dtypes(include=[np.number]).columns.tolist()
print("Variables num√©ricas disponibles:", variables_numericas)

var_lisa = input("üëâ Escribe el nombre EXACTO de la variable para an√°lisis LISA: ")

if var_lisa not in variables_numericas:
    raise ValueError(f"La variable '{var_lisa}' no es v√°lida o no es num√©rica.")

# === 4. Estandarizar variable
gdf_desborde[f'{var_lisa}_std'] = (gdf_desborde[var_lisa] - gdf_desborde[var_lisa].mean()) / gdf_desborde[var_lisa].std()

# === 5. Calcular LISA (Moran Local)
lisa = Moran_Local(gdf_desborde[f'{var_lisa}_std'], w_dist)

# Guardar estad√≠sticas en el GeoDataFrame
gdf_desborde["LISA_I"] = lisa.Is
gdf_desborde["LISA_p"] = lisa.p_sim
gdf_desborde["LISA_q"] = lisa.q  # cuadrante: 1 = HH, 2 = LH, 3 = LL, 4 = HL
gdf_desborde["LISA_sig"] = lisa.p_sim < 0.05  # significancia al 5%

# === 6. Clasificar en categor√≠as interpretables
def clasificar_lisa(row):
    if not row["LISA_sig"]:
        return "No significativo"
    elif row["LISA_q"] == 1:
        return "Alto-Alto"
    elif row["LISA_q"] == 2:
        return "Bajo-Alto"
    elif row["LISA_q"] == 3:
        return "Bajo-Bajo"
    elif row["LISA_q"] == 4:
        return "Alto-Bajo"
    else:
        return "Desconocido"

gdf_desborde["LISA_tipo"] = gdf_desborde.apply(clasificar_lisa, axis=1)

# === 7. Mapa de clusters LISA ===
# Reproyectar para mostrar con mapa base
gdf_plot = gdf_desborde.to_crs(epsg=3857)

# Paleta de colores para los tipos
colores_lisa = {
    "Alto-Alto": "#d7191c",
    "Bajo-Bajo": "#2c7bb6",
    "Alto-Bajo": "#fdae61",
    "Bajo-Alto": "#abdda4",
    "No significativo": "lightgray"
}

fig, ax = plt.subplots(figsize=(10, 10))

gdf_plot.plot(
    ax=ax,
    column="LISA_tipo",
    categorical=True,
    legend=True,
    legend_kwds={"loc": "lower left"},
    color=gdf_plot["LISA_tipo"].map(colores_lisa),
    edgecolor="black",
    linewidth=0.2,
    markersize=50
)

ctx.add_basemap(ax, source=ctx.providers.CartoDB.Positron)
ax.set_title(f"Mapa de clusters LISA ‚Äì {var_lisa}", fontsize=14)
ax.set_axis_off()
plt.tight_layout()
plt.show()